package minic;
import java_cup.runtime.*;
import java.io.FileReader;

/* Codigo de nuestro parser */
parser code {:
  
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error ");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            m.append("Sintactico: simbolo: " + s.value.toString()+ " no reconocido.");
            if (s.left >= 0) {                
                m.append(" linea "+(s.left+1));
                if (s.right >= 0)
                    m.append(", columna "+(s.right+1));
            }
        }        
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            System.out.println("\n*** Resultados finales ***");
            Sintaxis asin = new Sintaxis(
                    new Lexer( new FileReader(args[0])));
            Object result = asin.parse().value;            
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};

/* ------------Declaracion de simbolos terminales y no terminales---------- *

/*--------------TERMINALES-----------*/
terminal VOID, INT, DOUBLE, BOOL, STRING, CLASS, INTERFACE, NULL, THIS, EXTENDS, IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, NEW, NEWARRAY, PRINT, READINTEGER, READLINE, MALLOC, IDENT, GETBYTE, SETBYTE, PLUS, MINUS, TIMES, DIV, MOD, LESS, LESSEQ, GREATER, GREATEREQ, EQUALS, EQTO, NOTEQ, AMPERSONS, OR, EXCLAM, SEMI, COMMA, PERIOD, LCOR, RCOR, LPAR, RPAR, LLLAV, RLLAV, CORS, PARS, LLAVS, CONSTANT;
terminal Object intConstant, doubleConstant, boolConstant, stringConstant, hexConstant;

/*--------------NO TERMINALES-----------*/
non terminal  Program, Decl, VariableDecl, Variable, Type, FunctionDecl, Formals, ClassDecl, Field, InterfaceDecl, Prototype, StmtBlock, Stmt, IfStmt, WhileStmt, ForStmt, ReturnStmt, BreakStmt, PrintStmt, Expr,Expr1, LValue, Call, LibCall, Actuals, Constant, Ext, Imp, ImpID, ProtCont, FuncCont, StmtExpr, ExprPrint, ElseIfStmt, ClassField, InterfaceProt, CallCont,FormalsCont, StmtEnd, StmtCont, VarConstant;

/*--------------PRECEDENCIAS-----------*/
precedence left EQUALS;
precedence left PLUS, MINUS, TIMES, DIV, MOD;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQTO, NOTEQ, AMPERSONS, OR, EXCLAM ;
precedence left ELSE;
precedence left IDENT;
precedence left DOUBLE,BOOL,STRING,INT;
/* -------------------GRAMATICA FORMAL------------------------ */

Program ::= Program Decl
| /* ε */ ;

Decl ::= VariableDecl
| FunctionDecl
| ClassDecl
| InterfaceDecl
| error SEMI
| error RLLAV ;

VariableDecl ::= Variable SEMI ;

Variable ::= VarConstant Type:t IDENT:I {: if (!Env.put(I,t))  System.out.println("  La variable " + I + " ya ha sido declarada en el ambito actual"); :} ;

VarConstant ::= CONSTANT
| /* ε */ ;

Type ::= INT {: RESULT = "int"; :}
| DOUBLE {: RESULT = "double"; :}
| BOOL {: RESULT = "bool"; :}
| STRING {: RESULT = "string"; :}
| IDENT:n1 {: RESULT = n1.toString(); :}
| Type CORS ;

FunctionDecl ::= Type FuncCont
| VOID FuncCont ;

FuncCont ::= IDENT LPAR Formals RPAR StmtBlock ;

Formals ::= FormalsCont Variable
| /* ε */ ;

FormalsCont ::= FormalsCont Variable COMMA
| /* ε */ ;

ClassDecl ::= CLASS IDENT:n1 Ext:n2   
{:
    if(n2 == null)
    {
        if(Env.putClass(n1.toString(),null,"class") != 0)
        {
            System.out.println("  La clase " + n1 + " ya ha sido declarada en el ambito actual");
        }
    }
    else
    {
        switch(Env.putClass(n1.toString(),n2.toString(),"class"))
        {
            case 1:
            System.out.println("  La clase " + n1 + " ya ha sido declarada en el ambito actual");
            break;

            case 2:
            System.out.println("  La clase " + n2 + " no existe en el ambito actual");
            break;                
        } 
    }
:} 
Imp LLLAV ClassField RLLAV 
{:
      System.out.print("  Saliendo de la clase: "+n1);
      Env.pop();
 :} ;

Ext ::= EXTENDS IDENT:n1 {: RESULT = n1; :}
| /* ε */ ;

Imp ::= IMPLEMENTS ImpID:e
| /* ε */ ;

ImpID ::= ImpID COMMA IDENT
| IDENT:e
{:

    if(n3 == null)
    {
        
    }
    else
    {   
        boolean R = Env.getInterfaces(n3.toString());

        if(R == false)
        {
            System.out.println("  La interfaz " + n3 + " no existe en el ambito actual");
        }
    }
 :} ;

ClassField ::= ClassField Field
| /* ε */ ;

Field ::= VariableDecl
| FunctionDecl ;

InterfaceDecl ::= INTERFACE IDENT:n1 {: if(Env.putClass(n1.toString(),null,null) != 0) System.out.println("  La interfaz " + n1 + " ya ha sido declarada en el ambito actual"); :} LLLAV InterfaceProt RLLAV ;

InterfaceProt ::= InterfaceProt Prototype
| /* ε */ ;

Prototype ::= Type ProtCont
| VOID ProtCont;

ProtCont ::= IDENT LPAR Formals RPAR SEMI ;

StmtBlock ::= LLLAV StmtCont RLLAV ;

StmtCont ::= StmtEnd StmtCont
| /* ε */ ;

StmtEnd ::= VariableDecl
| Stmt ;

Stmt ::= StmtExpr SEMI
| IfStmt
| WhileStmt
| ForStmt
| BreakStmt
| ReturnStmt
| PrintStmt
| StmtBlock ;

StmtExpr ::= Expr
| /* ε */ ;

IfStmt ::= IF LPAR Expr RPAR Stmt ElseIfStmt ;

ElseIfStmt ::= ELSE Stmt
| /* ε */ ;

WhileStmt ::= WHILE LPAR Expr RPAR Stmt ;

ForStmt ::= FOR LPAR StmtExpr SEMI Expr SEMI StmtExpr RPAR Stmt ;

ReturnStmt ::= RETURN StmtExpr SEMI ;

BreakStmt ::= BREAK SEMI ;

PrintStmt ::= PRINT LPAR ExprPrint RPAR SEMI ;

ExprPrint ::= ExprPrint COMMA Expr
| Expr ;

Expr ::= LValue:v EQUALS Expr:e 
{: 
    Env.Validar(v.toString(), e.toString());
:} 
| Constant:e {: RESULT = e; :}
| LValue:e {: RESULT = e; :}
| THIS
| Call 
| LPAR Expr RPAR
| Expr1:e1 PLUS Expr:e2 {: RESULT = e1 + "+" + e2; :}
| Expr1:e1 MINUS Expr:e2 {: RESULT = e1 + "-" + e2; :}
| Expr1:e1 TIMES Expr:e2 {: RESULT = e1 + "*" + e2; :}
| Expr1:e1 DIV Expr:e2 {: RESULT = e1 + "/" + e2; :}
| Expr MOD Expr
| MINUS Expr
| Expr LESS Expr
| Expr LESSEQ Expr
| Expr GREATER Expr
| Expr GREATEREQ Expr
| Expr EQTO Expr
| Expr NOTEQ Expr
| Expr AMPERSONS Expr
| Expr OR Expr
| EXCLAM Expr
| NEW LPAR IDENT RPAR
| NEWARRAY LPAR Expr COMMA Type RPAR
| READINTEGER LPAR RPAR
| READLINE LPAR RPAR
| MALLOC LPAR Expr RPAR ;

Expr1 ::= Constant:e {: RESULT = e; :}
| IDENT:e {: RESULT = e; :} ;

LValue ::= IDENT:e {: RESULT = e; :}
| Expr PERIOD IDENT
| Expr LCOR Expr RCOR ;

Call ::= IDENT LPAR Actuals RPAR 
| Expr PERIOD IDENT CallCont
| Expr PERIOD LibCall CallCont ;

CallCont ::= LPAR Actuals RPAR ;

LibCall ::= GETBYTE LPAR Expr RPAR 
| SETBYTE LPAR Expr COMMA Expr RPAR ;

Actuals ::= ExprPrint
| /* ε */ ;

Constant ::= intConstant:e {: RESULT = e; :}
| doubleConstant:e {: RESULT = e; :}
| boolConstant
| stringConstant:e {: RESULT = e; :}
| NULL ;